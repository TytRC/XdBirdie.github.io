{"meta":{"title":"BIRDIE","subtitle":"Like a BIRDIE flies into your heart...","description":"","author":"Rain Chen","url":"http://blog.raincur.com","root":"/"},"pages":[{"title":"categories","date":"2020-02-25T15:30:59.000Z","updated":"2020-02-25T15:31:29.670Z","comments":false,"path":"categories/index.html","permalink":"http://blog.raincur.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-26T08:44:05.725Z","updated":"2020-10-26T04:08:51.648Z","comments":true,"path":"links/index.html","permalink":"http://blog.raincur.com/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-25T15:26:40.000Z","updated":"2020-02-25T15:29:46.548Z","comments":false,"path":"tags/index.html","permalink":"http://blog.raincur.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-26T11:59:38.762Z","updated":"2020-10-26T11:59:38.762Z","comments":true,"path":"tags/links.json","permalink":"http://blog.raincur.com/tags/links.json","excerpt":"","text":"{\"程爷\":{\"link\":\"https://blog.csdn.net/zimuzi2019\",\"avatar\":\"https://avatar.csdnimg.cn/0/B/4/3_zimuzi2019_1588336452.jpg\",\"desc\":\"牛逼就完事了\"},\"安宁大大\":{\"link\":\"https://blog.csdn.net/qq_46003570\",\"avatar\":\"/images/links_avatar/jsy.jpg\",\"desc\":\"媛姐\"},\"STYX Wang\":{\"link\":\"http://blog.zr.codes\",\"avatar\":\"http://blog.zr.codes/static/image/touxiang.jpg\",\"desc\":\"zr聚聚全栈\"}}"}],"posts":[{"title":"LINGO的基本使用","slug":"LINGO的基本使用","date":"2021-01-20T15:00:21.188Z","updated":"2021-01-21T03:23:17.206Z","comments":true,"path":"2021/01/20/LINGO的基本使用/","link":"","permalink":"http://blog.raincur.com/2021/01/20/LINGO%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Lingo基础 Lingo解方程 每个语句以分号结尾 2∗x2 * x2∗x不能简写为2x2x2x Lingo默认所有的变量均大于等于0 利用函数@free可以使其定义域为RRR Lingo不区分大小写 注释以!开头，以;结尾 线性规划基础 一个线性规划中只含一个目标函数，多目标线性规划需要转化为单目标规划 求目标函数最大值或最小值分别用max=或min= 线性规划与非线性规划的本质区别是目标函数是否线性，故不作区分 求解非线性规划非常困难，所以尽量转化为线性规划求解 集合与矩阵工厂 问题场景： 求解： max Ss.t.{S=aixi,i=1,2,...,5ai=1,i=1,2,...,5∑i=15xi=5000max\\ S\\\\ s.t.\\left\\{ \\begin{aligned} &amp; S=a_ix_i,&amp; i=1,2,...,5 \\\\ &amp;a_i=1,&amp; i=1,2,...,5\\\\ &amp;\\sum_{i=1}^5x_i=5000 &amp; \\\\ \\end{aligned} \\right. max Ss.t.⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​​S=ai​xi​,ai​=1,i=1∑5​xi​=5000​i=1,2,...,5i=1,2,...,5​ 我们可以枚举，利用如下lingo代码求解： 12345678max &#x3D; s;s &#x3D; a1 * x1;s &#x3D; a2 * x2;s &#x3D; a3 * x3;s &#x3D; a4 * x4;s &#x3D; a5 * x5;a1 &#x3D; 1; a2 &#x3D; 2; a3 &#x3D; 3; a4 &#x3D; 4; a5 &#x3D; 5;x1 + x2 + x3 + x4 + x5 &#x3D; 5000; 显然这种场景暴力分解太憨批了，所以我们寻求另一种表示方法：lingo中非常重要的集合，或者称之为矩阵工厂。 矩阵工厂（一维矩阵） 1234sets:factory&#x2F;1..4&#x2F;: a, b;plant&#x2F;1..3&#x2F;: x, y;endsets factory和plant都是生产矩阵的工厂 factory、plant和a、b、x、y的名字是随便取的 factory生产1*6的矩阵，plant生成1*3的矩阵 生产完矩阵之后，工厂和矩阵之间几乎没有关系 sets:和endsets用于表示工厂生产流程起止 矩阵的赋值 承接上面代码，增加： 12345data:a &#x3D; 1, 2, 3, 4, 5, 6;b &#x3D; 6.0, 5.0, 4.0, 3.0, 2.0, 1.0;x &#x3D; 1;enddata 运行结果如下： 123456789101112131415Variable ValueA( 1) 1.000000A( 2) 2.000000A( 3) 3.000000A( 4) 4.000000B( 1) 6.000000B( 2) 5.000000B( 3) 4.000000B( 4) 3.000000X( 1) 1.000000X( 2) 1.000000X( 3) 1.000000Y( 1) 0.000000Y( 2) 0.000000Y( 3) 0.000000 不是每个矩阵都要赋初值 要么赋满，要么全都设为一样 data:和enddata标注起止 循环与求和 上述题目可以用以下代码求解： 1234567sets:f&#x2F;1..5&#x2F;: a, x;endsetsmax &#x3D; s;@for(f(i): a(i) * x(i) &#x3D; s);@for(f(i): a(i) &#x3D; i);!可用data:a&#x3D;1,2,3,4,5;enddata@sum(f(i):x(i)) &#x3D; 5000; @for()表示循环，先写工厂，表示循环次数 @sum()表示求和，先写工厂，表示求和元素 在一维的情况下，可以改写为类似@for(f: a * x = s); 二维矩阵 求解： min z=∑i=16∑j=18cijxijs.t.{∑j=18xij≤ai,i=1,2,...,6∑i=16xij=dj,j=1,2,...,8xij≥0,i=1,2,...,6,j=1,2,...,8 min\\ z = \\sum_{i=1}^6\\sum_{j=1}^8c_{ij}x_{ij}\\\\ s.t.\\left\\{ \\begin{aligned} &amp;\\sum_{j=1}^8x_{ij}\\leq a_i, &amp;i=1,2,...,6\\\\ &amp;\\sum_{i=1}^6x_{ij}=d_j, &amp;j=1,2,...,8\\\\ &amp;x_{ij}\\geq0, &amp;i=1,2,...,6,j=1,2,...,8 \\end{aligned} \\right. min z=i=1∑6​j=1∑8​cij​xij​s.t.⎩⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎧​​j=1∑8​xij​≤ai​,i=1∑6​xij​=dj​,xij​≥0,​i=1,2,...,6j=1,2,...,8i=1,2,...,6,j=1,2,...,8​ 其中： 12345678a &#x3D; 60,55,51,43,41,52d &#x3D; 35,37,22,32,41,32,43,38c &#x3D; 6,2,6,7,4,2,5,8 4,9,5,3,8,5,8,2 5,2,1,9,7,4,3,3 7,6,7,3,9,2,7,1 2,3,9,5,7,2,6,5 5,5,2,2,8,1,4,3 lingo代码为： 12345678910111213141516171819202122232425model:sets:row/1..6/: a;col/1..8/: d;factory(row, col): c, x;endsetsdata:a = 60,55,51,43,41,52;d = 35,37,22,32,41,32,43,38;c = 6,2,6,7,4,2,5,8 4,9,5,3,8,5,8,2 5,2,1,9,7,4,3,3 7,6,7,3,9,2,7,1 2,3,9,5,7,2,6,5 5,5,2,2,8,1,4,3;enddata!min = @sum(row(i):@sum(col(j): c(i,j)*x(i,j)));min = @sum(factory(i, j): c(i, j)*x(i, j));@for(row(i): @sum(col(j): x(i, j)) &lt;= a(i));@for(col(j): @sum(row(i): x(i, j)) = d(j));end 内置函数 数学函数 函数 作用 @abs(x) 返回xxx的绝对值 @sin(x) 返回xxx的正弦值，xxx采用弧度制 @cos(x) 返回xxx的余弦值 @tan(x) 返回xxx的正切值 @exp(x) 返回常数eee的xxx次方 @log(x) 返回xxx的自然对数 @lgm(x) 返回xxx的gammagammagamma函数的自然对数 @sign(x) 如果x&lt;0x&lt;0x&lt;0返回−1-1−1；否则，返回111 @floor(x) 返回xxx的整数部分。当x≥0x\\geq0x≥0时，返回不超过xxx的最大整数；当x&lt;0x&lt;0x&lt;0时，返回不低于xxx的最大整数。 @smax(x1,x2,…,xn) 返回x1,x2,...,xnx_1,x_2,...,x_nx1​,x2​,...,xn​中的最大值 @smin(x1,x2,…,xn) 返回x1,x2,...,xnx_1,x_2,...,x_nx1​,x2​,...,xn​中的最小值 变量界定函数 函数 作用 @bin(x) 限制xxx只能取000或111 @gin(x) 限制xxx只能取整数 @bnd(L, x, U) 限制L≤x≤UL\\leq x\\leq UL≤x≤U @free(x) 取消对变量xxx的默认下界为0的限制","categories":[],"tags":[]},{"title":"Cellular-automata","slug":"Cellular-automata","date":"2021-01-20T13:20:23.427Z","updated":"2021-01-20T14:37:29.112Z","comments":true,"path":"2021/01/20/Cellular-automata/","link":"","permalink":"http://blog.raincur.com/2021/01/20/Cellular-automata/","excerpt":"","text":"应用","categories":[],"tags":[]},{"title":"queuing-theory","slug":"queuing-theory","date":"2021-01-20T07:40:38.180Z","updated":"2021-01-20T13:34:27.890Z","comments":true,"path":"2021/01/20/queuing-theory/","link":"","permalink":"http://blog.raincur.com/2021/01/20/queuing-theory/","excerpt":"","text":"排队论 排队论的基本构成 输入过程：描述顾客按照怎样的规律到达排队系统。顾客总体（有限/无限），到达的类型（单个/成批）、到达时间间隔等。 排队规则：指顾客按怎样的规定次序接受服务。常见的有等待制、损失制、混合制、闭合制等。 服务机构：服务台的数量；服务时间服从的分布。 排队系统的数量指标 队长：系统中的平均顾客数（包括正在接受服务的顾客） 等待队长：系统中处于等待的顾客的数量 等待时间：等待时间包括顾客的平均逗留时间 忙期：连续保持服务的时长 排队论中的符号表示 A/B/C/nA/B/C/n A/B/C/n AAA输入过程，BBB服务时间，CCC服务台数，nnn系统容量。 例如：M/M/S/∞M/M/S/\\inftyM/M/S/∞ 输入过程是PoissonPoissonPoisson流 服务时间服从负指数分布 系统有SSS个服务台平行服务 系统容量为无穷大的等待制排队系统 参数为λ\\lambdaλ的PoissonPoissonPoisson分布： Pn(t)=(λt)nn!e−λtP_n(t) = \\frac{(\\lambda t)^n}{n!}e^{-\\lambda t} Pn​(t)=n!(λt)n​e−λt [0,t][0,t][0,t]时间内到达的顾客平均数为λt\\lambda tλt。 参数为μ\\muμ的负指数分布： f(t)=μe−μt(t&gt;0)f(t) =\\mu e^{-\\mu t}(t&gt;0) f(t)=μe−μt(t&gt;0) 每个顾客接受服务的平均时间为1μ\\frac{1}{\\mu}μ1​。 那么假设λ≥μ\\lambda \\geq \\muλ≥μ，那么显然服务队列中的人数将趋于无穷，队列是不稳定的。 重要统计量 系统的服务强度：ρ=λμ\\rho = \\frac{\\lambda}{\\mu}ρ=μλ​ 无顾客的概率：p0=1−ρ=1−λμp_0 = 1 - \\rho = 1 - \\frac{\\lambda}{\\mu}p0​=1−ρ=1−μλ​ 有nnn个顾客的概率：ρn=(1−ρ)ρn\\rho_n = (1 - \\rho)\\rho^nρn​=(1−ρ)ρn 平均队长：Ls=∑n=0∞npn=(1−ρ)∑n=0∞nρn=ρ1−ρ=λμ−λL_s = \\sum_{n=0}^\\infty np_n = (1 - \\rho)\\sum_{n=0}^\\infty n\\rho^n=\\frac{\\rho}{1-\\rho}=\\frac{\\lambda}{\\mu-\\lambda} Ls​=n=0∑∞​npn​=(1−ρ)n=0∑∞​nρn=1−ρρ​=μ−λλ​ 平均等待队长：Lq=∑n=1∞(n−1)pn=(1−ρ)∑n=1∞(n−1)ρn=ρ21−ρ=λ2μ(μ−λ)L_q=\\sum_{n=1}^\\infty(n-1)p_n=(1-\\rho)\\sum_{n=1}^\\infty(n-1)\\rho^n=\\frac{\\rho^2}{1-\\rho}=\\frac{\\lambda^2}{\\mu(\\mu-\\lambda)} Lq​=n=1∑∞​(n−1)pn​=(1−ρ)n=1∑∞​(n−1)ρn=1−ρρ2​=μ(μ−λ)λ2​ 平均逗留时间：Ws=1μ−λW_s=\\frac{1}{\\mu-\\lambda} Ws​=μ−λ1​ 平均等待时间：Wq=1μ−λ−1μ=λμ(μ−λ)W_q=\\frac{1}{\\mu-\\lambda}-\\frac{1}{\\mu}=\\frac{\\lambda}{\\mu(\\mu-\\lambda)} Wq​=μ−λ1​−μ1​=μ(μ−λ)λ​ LittleLittleLittle公式：Ls=λWs,Lq=λWqL_s=\\lambda W_s, L_q=\\lambda W_q Ls​=λWs​,Lq​=λWq​ 等待制模型 M/M/S/∞M/M/S/\\inftyM/M/S/∞：S&gt;1S&gt;1S&gt;1 服务能力和强度：Sμ,ρ=λsμS\\mu,\\rho = \\frac{\\lambda}{s\\mu} Sμ,ρ=sμλ​ 服务台都空闲的概率：p0=[∑k=0S−1(Sρ)kk!+(Sρ)SρS!(1−ρ)]−1p_{0}=\\left[\\sum_{k=0}^{S-1} \\frac{(S \\rho)^{k}}{k !}+\\frac{(S \\rho)^{S} \\rho}{S !(1-\\rho)}\\right]^{-1} p0​=[k=0∑S−1​k!(Sρ)k​+S!(1−ρ)(Sρ)Sρ​]−1 平均队长Ls=Sρ+(Sρ)SρS!(1−ρ)2⋅p0L_{s}=S \\rho+\\frac{(S \\rho)^{S} \\rho}{S !(1-\\rho)^{2}} \\cdot p_{0} Ls​=Sρ+S!(1−ρ)2(Sρ)Sρ​⋅p0​ 其他模型 损失制模型 M/M/S/SM/M/S/SM/M/S/S 顾客到达服从泊松分布，服务台服务时间服从指数分布 当SSS个服务台被占用后，顾客自动离开，不再等待 混合制模型 M/M/S/KM/M/S/KM/M/S/K 顾客到达服从泊松分布，服务台服务时间服从指数分布 系统容量为KKK，当K个位置被占用时，顾客自动离开 闭合制模型 M/M/S/K/KM/M/S/K/KM/M/S/K/K 顾客到达服从泊松分布，服务台服务时间服从指数分布 系统容量和潜在的顾客数都为KKK","categories":[],"tags":[]},{"title":"Logistic-regression","slug":"Logistic-regression","date":"2021-01-18T08:29:21.427Z","updated":"2021-01-18T09:26:08.903Z","comments":true,"path":"2021/01/18/Logistic-regression/","link":"","permalink":"http://blog.raincur.com/2021/01/18/Logistic-regression/","excerpt":"","text":"梯度下降与逻辑回归 承接梯度下降实现线性拟合矩阵推导及实现，线性回归用于拟合线性关系的数据。而逻辑回归更多用于二分类。即，因变量的值从连续的值变成了离散的{0,1}\\{0,1\\}{0,1}。在这种语意下，我们重新选取假设函数和损失函数，并按照与求解线性回归的梯度下降同样的思路，进行参数拟合。 在这里，我们将重点阐述假设函数和损失函数，以及相应的梯度求解。 假设函数 假设函数其实就是我们选取的符合数据分布的函数形式。在线性回归中，我们定义假设函数为θTx\\theta^TxθTx，而在逻辑回归中，我们引入sigmoidsigmoidsigmoid函数。 sigmoid(z)=g(z)=11+e−zsigmoid(z) = g(z) = \\frac{1}{1+e^{-z}} sigmoid(z)=g(z)=1+e−z1​ 函数图像如下： 我们发现该函数为严格增函数，定义域为(−∞,∞)(-\\infty,\\infty)(−∞,∞)，值域为(0,1)(0,1)(0,1)，lim⁡z→∞g(z)=1,lim⁡z→−∞=0\\lim_{z\\rightarrow \\infty}g(z)=1,\\lim_{z\\rightarrow -\\infty} = 0limz→∞​g(z)=1,limz→−∞​=0。也就是说，通过这个函数，我们将实数映射到了(0,1)(0,1)(0,1)区间。我们将这个函数作用于线性回归的假设函数，得到逻辑回归的假设函数。","categories":[],"tags":[]},{"title":"对我高中以来学习的反思","slug":"Reflection-on-my-learning-since-high-school","date":"2020-07-28T05:37:20.000Z","updated":"2020-11-02T03:05:31.774Z","comments":true,"path":"2020/07/28/Reflection-on-my-learning-since-high-school/","link":"","permalink":"http://blog.raincur.com/2020/07/28/Reflection-on-my-learning-since-high-school/","excerpt":"“恕我直言，能够带来思想快乐的东西，只能是人类智慧至高的产物。“","text":"“恕我直言，能够带来思想快乐的东西，只能是人类智慧至高的产物。“ 我是喜欢数学的，起码一直以来我是这么认为的。 从小学开始，或者从幼儿园开始我的数学成绩一直名列前茅，谦虚点说，不算太差。我享受得到数学所能带给我的乐趣。那种冥思苦想之后的顿悟，仿佛大旱之后的甘霖。我的数学一直以来学得随意，会被技巧折服，而不会为解题去学习。我喜欢我不会的东西，就正如王小波先生写的“这就如和一位高明的棋手下棋，虽然自己总被击败，但也有机会领略妙招。”我期待着的仅仅是学习更多，所以我期待新的不会的东西。 高中之后数学渐渐地使我没那么快乐了。数学没有变。我开始渐渐地关心数学之外的事情，我的成绩，我的排名，高考，大学。学习数学不再是一种精神上的愉悦，它给我带来了负担。曾经遇见一个不会的问题，会兴奋，会苦恼，会为自己又能学到新东西而开心。而当我越来越关注那个量化的量之后，每一道错题都令我害怕，每一个未曾见过的技巧使我慌张，每一次面对题目（做过的没做过的）都使我焦虑不安。我在害怕，我不害怕数学，我害怕数学之外的东西，害怕不能考高分。错误不再意味着学习，错误更多成了自我的否定。 我曾可以一个晚上只做数学，而懊恼为什么会有其他的科目占用我的时间。现在我有大把的时间，但是我不愿意去看数学，做了题目不愿意去对答案。我不愿面对错误。而因此我必须去面对更多的错误，因为我只在原地踏步。如此，恶性循环。 我觉得我有必要摆正一下自己的心态，不再去管那些有的没的糟糕的东西。没必要去争那个最前面的东西，或者说没必要带着这种想法去学习。我给自己设下设下保护伞——至少，你总会可以养活自己。希望可以多一些随意，少一些功利性的东西。竞争是必要的，但没必要太上心。 “恕我直言，能够带来思想快乐的东西，只能是人类智慧至高的产物。比这再低一档的东西，只会给人带来痛苦；而这种低档货，就是出于功利的种种想法。”","categories":[{"name":"随笔杂谈","slug":"随笔杂谈","permalink":"http://blog.raincur.com/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.raincur.com/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"Reflection","slug":"Reflection","permalink":"http://blog.raincur.com/tags/Reflection/"}]},{"title":"欧拉定理与费马小定理","slug":"欧拉定理与费马小定理","date":"2020-07-10T10:53:22.000Z","updated":"2020-11-02T03:42:10.344Z","comments":true,"path":"2020/07/10/欧拉定理与费马小定理/","link":"","permalink":"http://blog.raincur.com/2020/07/10/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E4%B8%8E%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","excerpt":"欧拉定理与费马小定理的证明。本文参考自 $OIWiki$，并对证明结构进行了改进。原文链接：欧拉定理 &amp; 费马小定理","text":"欧拉定理与费马小定理的证明。本文参考自 $OIWiki$，并对证明结构进行了改进。原文链接：欧拉定理 &amp; 费马小定理 费马小定理内容若 $p$ 为素数，$gcd(a,p)=1$，则 $a^{p-1}\\equiv1\\pmod{p}$。 证明思路考虑集合 $A$ 为模 $p$ 意义下的最小完整剩余系，即 $A=\\{1,2,…,p-1\\}$。而集合 $B$ 为 $\\{1a,2a,…,(p-1)a\\}$。我们将证明集合 $B$ 在模 $p$ 意义下与集合 $A$ 是一一对应关系，即集合 $B$ 也是模 $p$ 意义下的完整剩余系。 由此，我们可以应用公式： \\begin{align} & 1a\\cdot2a\\cdot...\\cdot(p-1)a &\\equiv1\\cdot2\\cdot...\\cdot(p-1)&\\pmod{p}\\\\ \\Rightarrow & a^{p-1}\\cdot1\\cdot2\\cdot...\\cdot(p-1) &\\equiv1\\cdot2\\cdot...\\cdot(p-1)&\\pmod{p}\\\\ \\Rightarrow & a^{p-1} \\equiv 1 \\pmod{p} \\end{align}即证明得到费马小定理。 主要证明过程下面我们证明集合 $A,B$ 是一一对应关系。为此，我们可以证明 $\\forall i\\neq j,ia\\not\\equiv ja \\pmod{p}$。 应用反证法，假设 $\\exist i\\neq j,ia\\equiv ja \\pmod{p}$，同时不妨设 $i &gt; j$，那么我们可以得到 $(i-j)a \\mid p$。而由题设我们可以得到 $gcd(a,p)=1$，且 $0&lt;(i-j)&lt;p$，$p$ 是质数，所以 $gcd(i-j,p)=1$。所以 $(i-j)a\\nmid p$，矛盾。 于是我们证明了 $\\forall i\\neq j,ia\\not\\equiv ja \\pmod{p}$，即证明了集合 $A,B$ 的一一对应关系。由此根据先前的推到，我们证明得到了费马小定理。 欧拉定理内容欧拉定理可以视为费马小定理的推广形式，定理内容如下： if\\ gcd(a,m)=1,then\\ a^{\\phi(m)}\\equiv 1\\pmod{m}当 $m$ 为质数时，$\\phi(m)=m-1$，我们即得到了费马小定理。 证明思路欧拉定理具体的证明思路与费马小定理相仿，我们利用模 $m$ 意义下的简化剩余系 $r_1,r_2,…,r_{\\phi(m)}$ ，我们对其每一个元素乘 $a$ ，得到 $ar_1,ar_2,…,ar_{\\phi(m)}$，我们将证明这样操作得到的集合仍然是模 $m$ 意义下的简化剩余系。按照对费马小定理相同的处理方式，我们可以证明得到欧拉定理。 主要证明过程我们将证明以下两点： $ar_i$ 与 $m$ 互质 $\\because gcd(a,m)=1，gcd(r_i,m)=1$ $\\therefore gcd(ar_i,m)=1$ $\\forall i\\neq j，ar_i\\not\\equiv ar_j \\pmod{m}$ 应用反证法，与费马小定理证明相仿，故在此略去。 $\\therefore ar_1,ar_2,…,ar_{\\phi(m)}$ 也是模 $m$ 意义下的一个简化剩余系。 $\\therefore ar_1\\cdot ar_2\\cdot…\\cdot ar_{\\phi(m)} \\equiv r_1 \\cdot r_2 \\cdot…\\cdot r_{\\phi(m)} \\pmod{m}$ 即得到 a^{\\phi(m)}\\equiv 1 \\pmod{m}拓展欧拉定理内容拓展欧拉定理时在比赛刷题中常用的公式，可以很方便的讲一个看似根本不可能计算的幂次方（甚至幂套幂套幂……）逐步通过取模简化至可以计算的形式。与快速幂一次食用效果更佳。 \\begin{equation} a^b \\equiv \\left\\{ \\begin{array} aa^{b \\mod {\\phi(p)}},& gcd(a,p)=1\\\\ a^b,& gcd(a,p)\\neq 1,b","categories":[{"name":"ACM-Math","slug":"ACM-Math","permalink":"http://blog.raincur.com/categories/ACM-Math/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://blog.raincur.com/tags/ACM/"},{"name":"learning","slug":"learning","permalink":"http://blog.raincur.com/tags/learning/"},{"name":"Math","slug":"Math","permalink":"http://blog.raincur.com/tags/Math/"}],"author":"Rain Chen"},{"title":"欧拉函数的积性证明","slug":"欧拉函数","date":"2020-07-06T16:41:32.000Z","updated":"2020-11-02T03:22:02.476Z","comments":true,"path":"2020/07/07/欧拉函数/","link":"","permalink":"http://blog.raincur.com/2020/07/07/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"对于欧拉函数是积性函数的证明","text":"对于欧拉函数是积性函数的证明 欧拉函数的积性证明积性函数积性函数 是指对于函数$ f $，当$ gcd(m, n) = 1 $时，$f(m)f(n) = f(mn)$。 完全积性函数 是指对于函数$f$，$f(m)(n) = f(mn)$。 下面我们将证明欧拉函数是积性函数。 证明目标等式： $\\phi(m)\\phi(n) = \\phi(mn)$ 符号约定$\\phi(n)$：欧拉函数 $X$ ： $m$ 的简化剩余系 $Y$ ： $n$ 的简化剩余系 $Z$ ： $mn$ 的简化剩余系 $x_i$ ：$X$ 的代表元素 $y_i$ ： $Y$ 的代表元素 $z$ ： $Z$ 的代表元素 $(x,y)$ ： $x，y$ 的最大公约数 证明思路 我们构造等式 $x_in+y_jm$ ，我们想要证明 $\\{x_in+y_jm\\}$ 和 $mn$ 的简化剩余系 $Z$ 之间存在一个双射关系，也就是说 $x_in+y_jm$ 的个数与 $mn$ 的简化剩余系的个数相同。 同时，我们将证明 $x_in+y_jm$ 当 $i，j$ 不同时不在同一剩余类中。这样得到 $x_in+y_im$ 可以表示 $\\phi(m)\\phi(n)$ 个不同的剩余类。目标等式得证。所以我们将证明： $x_in+y_jm\\in Z$ ，即 $gcd(x_in+y_jm,mn)=1$ $\\forall z,\\exist i, j, \\mbox{ s.t. } x_in+y_jm \\equiv z \\pmod{mn}$ 对于任意一个有序二元组$(i,j)\\neq(k,l)，$ $x_in+y_jm\\equiv x_kn+y_lm \\pmod{mn} $ $1,2$ 实际上证明了双射关系，$3$ 则证明了不在同一剩余类。 证明过程对1的证明(x_i,m)=1\\Longrightarrow(x_in,m)=1\\Longrightarrow(x_in,mn)=1 \\tag{1}(y_i,n)=1\\Longrightarrow(y_im,n)=1\\Longrightarrow(y_im,mn)=1 \\tag{2}由 $(1)，(2)$ 得 (x_im+y_jm,mn)=1 对2的证明由 $(m,n)=1$ 可得，存在 $p，q$ 使得 $mp+nq=z$。 那么，我们可以得到： $(z,mn)=1\\Rightarrow(mp+nq,mn)=1\\Rightarrow(mp+nq,m)=1\\Rightarrow(nq,m)=1\\Rightarrow(q,m)=1$ 由此可得，$q$ 在 $m$ 的简化剩余系中，所以 $\\exist x_i,x_i \\equiv q \\pmod{m}$，可以推得 x_in \\equiv qn \\pmod{mn} \\tag{3}同理，我们可以得到： y_jm \\equiv pm \\pmod{mn} \\tag{4}由 $(3),(4)$ 我们可以得到： x_in+y_jm \\equiv qn+ pm \\equiv z \\pmod{mn}对3的证明应用反证法，我们假设存在这样的有序二元组 $(i,j)$ 和 $(k,l)$ 满足 $(i,j)\\neq(k,l)$ 使得 $x_in+y_jm\\equiv x_kn+y_lm \\pmod{mn} $ ，那么我们有 ： $x_in+y_jm\\equiv x_kn+y_lm \\pmod{m} \\Rightarrow x_in \\equiv x_kn \\pmod{m} \\Rightarrow x_i \\equiv x_k \\pmod{m}$ ，而由题设我们可以知道 $\\forall i \\neq k, x_i \\not\\equiv x_k \\pmod{m}$，所以矛盾。 所以对于任意一个有序二元组$(i,j)\\neq(k,l)，$ $x_in+y_jm\\equiv x_kn+y_lm \\pmod{mn} $ 得证。 综上，证得欧拉函数为积性函数。","categories":[{"name":"ACM-Math","slug":"ACM-Math","permalink":"http://blog.raincur.com/categories/ACM-Math/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://blog.raincur.com/tags/ACM/"},{"name":"learning","slug":"learning","permalink":"http://blog.raincur.com/tags/learning/"},{"name":"Math","slug":"Math","permalink":"http://blog.raincur.com/tags/Math/"}]},{"title":"我们都是花剌子模国王","slug":"我们都是花剌子模国王","date":"2020-05-17T09:50:42.000Z","updated":"2020-05-21T15:44:42.517Z","comments":true,"path":"2020/05/17/我们都是花剌子模国王/","link":"","permalink":"http://blog.raincur.com/2020/05/17/%E6%88%91%E4%BB%AC%E9%83%BD%E6%98%AF%E8%8A%B1%E5%89%8C%E5%AD%90%E6%A8%A1%E5%9B%BD%E7%8E%8B/","excerpt":"读小波有感。","text":"读小波有感。 我们都是花剌子模国王前言&emsp;&emsp;王小波在《花刺子模信使问题》中写到： 据野史记载，中亚古国花刺子模有一古怪的风俗，凡是给君王带来好消息的信使，就会得到提升，给君王带来坏消息的人则会被送去喂老虎。 &emsp;&emsp;王小波评价说： “花刺子模的君王有一种近似天真的品行，以为奖励带来好消息的人，就能鼓励好消息的到来，处死带来坏消息的人，就能根绝坏消息。” 01&emsp;&emsp;这个国家是否真的有这个传统我们不得而知，也并不重要。有趣的地方在于一般人都是趋利避害的，君王相当于是自然中生存的法则，适者生存之后只剩下了报告好消息的信使。由此以来，花剌子王国真的变成了一个“好消息”王国，虽然这个好消息不过是浮在真相水面上的薄冰。 &emsp;&emsp;恰如“这盛世，如你所愿”。 02&emsp;&emsp;恰如，在这美妙的互联网时代，这美丽缤纷的互联网中总是上演着各种“撕逼”大战。双方往往是“自我群体高潮”，而对对方的理论不理不睬。人们根据言论而群分，在不利的“若水三千”中努力找到自己想看到的那“一瓢”，而对其他视而不见。努力维持着自己“爱豆”高尚的形象，把一切其他当作异己，把所有自己不愿相信的当作“洗脑”。最后只是为了遮蔽“烂”这个事实。 &emsp;&emsp;就像小波总结的： 我人认为，获得受欢迎的信息有三种方法：其一，从真实中索取、筛选；其二：对现有信息加以改造；其三：凭空捏造。 &emsp;&emsp;我们屡见不鲜，屡试不爽。 03&emsp;&emsp;除了“撕逼”大战，互联网自媒体时代中有着更鲜活的“好信使”，比如之前爆火然后被口诛笔伐的“咪蒙”。“好信使”的特点是要会说话，会说好话。当你窝在电脑旁抱着泡面麻木地看这电脑上的文字，你肯定更希望有人给你说看网文的好，而不说让你认清你如山高般的ddl和你颓废的人生。 &emsp;&emsp;正如你正幻想着自己是屏幕里爽文的主角，而不愿面对惨淡的人生。 &emsp;&emsp;正如你忽略着自己160的身高和体重，幻想着所有人都爱着你 &emsp;&emsp;而实际上如“咪蒙”般的营销号不是为了告诉你怎样生活，而是为了让你沉沦于现在的生活。他们甚至不在乎你读过会怎么样，他们只是想要在取悦你，让你情绪化，让你可以读他们的下一篇。 04&emsp;&emsp;不过细想过来，每个人都是逃避型的，而君主的故事实际上也发生在我们自己身上。每个人都喜欢爽文，除非他写的不够爽；每个人都会做白日梦，除非他不会做梦。 &emsp;&emsp;当我第一次读这一段时，如你一样，觉得这个君主脑子有问题。可常言道：“当你想要批评别人的时候，你最好先批评自己”。当我静下心来反思自己，我发现我们又何尝不是这样呢？ &emsp;&emsp;在高中时每次考试总有几个作弊的，奇怪的是每个人都知道这是自欺欺人，奇怪的是每个人都一直作弊而不愿面对自己学的不好的事实，每个人都在祈求高考晚一点来，这样好日子就不会到头。 &emsp;&emsp;这就像极了我那无数个考完试却不愿意对答案的晚上。 &emsp;&emsp;这就像极了我那不到最后一刻绝对不愿意写的ddl。 &emsp;&emsp;是我们趋利避害的本能，导致我们只能看到我们愿意看到的，听见我们想听见的。而事实上，坏消息和困难，还有人生中其他你不愿意面对的困境挫折，是客观存在的，无论你看不看它。当你一直不愿意去面对的时候，或许当那一刻真的来临，你能做的也只有继续抱头逃避。 &emsp;&emsp;不同的是有的人甘愿沉沦，在自己幻想的海洋里继续裸泳；有的人自命不凡，在命运无常的高山上勇攀高峰。 &emsp;&emsp;所以唯有真的勇士，才敢于直面惨淡的人生和淋血的现实。 05&emsp;&emsp;更多更广阔更现实的我们不做探讨。写这么多，其实就是想告诉大家，你是否也是那个花剌子国王呢？又或者你多大程度上是花剌子国王呢？逃避并不可耻，可耻的是甘愿逃避，甚至依恋逃避。 &emsp;&emsp;在说着“理智客观中立”的时候你是否想过你真的是所谓“理智客观公正”？在无可救药地相信着什么的时候你是否真的认为如此？还是说只不过是害怕自己错了。","categories":[{"name":"随笔杂谈","slug":"随笔杂谈","permalink":"http://blog.raincur.com/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.raincur.com/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"看法","slug":"看法","permalink":"http://blog.raincur.com/tags/%E7%9C%8B%E6%B3%95/"}],"author":"Rain Chen"},{"title":"Codeforces Global Round 7 Solution","slug":"Codeforces-Global-Round-7-Solution","date":"2020-03-25T14:07:54.000Z","updated":"2020-11-02T03:05:40.900Z","comments":true,"path":"2020/03/25/Codeforces-Global-Round-7-Solution/","link":"","permalink":"http://blog.raincur.com/2020/03/25/Codeforces-Global-Round-7-Solution/","excerpt":"&emsp;&emsp;Codeforces Global Round 7比赛练习题解，个人使用，参考自官方题解。","text":"&emsp;&emsp;Codeforces Global Round 7比赛练习题解，个人使用，参考自官方题解。 A. Bad Ugly Number描述：&emsp;&emsp;给定$n$($0 \\leq n \\leq 10^5$),找到任意一个数整数$s$，满足: $s &gt; 0$ $s$由$n$个数字组成 $s$中的任意一位数不等于$0$ $s$不能被它的各位整除 &emsp;&emsp;每个输出包括$t$组，若存在这样的$s$则输出一个，否则输出$-1$。 解题思路：&emsp;&emsp;构造题，当$n=1$时显然是找不到$s$的，输出$-1$，否则输出$22…223$，一共$n-1$个$2$。 程序实现：1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int t, n; cin &gt;&gt; t; while (t--)&#123; cin &gt;&gt; n; if (n == 1)&#123; cout &lt;&lt; -1 &lt;&lt; endl; continue; &#125; for(int i = 1;i &lt; n;i++) cout &lt;&lt; '2'; cout &lt;&lt; 3 &lt;&lt; endl; &#125; return 0;&#125; B. Maximums描述：&emsp;&emsp;你有一个非负整数数组 $a_1,a_2,…,a_n$ ，对于每一个 $1 \\leq i \\leq n$，令$x_i = \\max(0,a_1,…,a_{i-1})$。特别的，$x_1 = 0$。现在令$b_i = a_i - x_i$。给定$b[]$数组，要求输出$a[]$数组。 解题思路：&emsp;&emsp;由于$x_1 = 0$，那么显然有$a_1 = b_1$。显然由$a_1,…,a_i$已知，可以推出$x_{i+1}$，进而推出$a_{i+1}$，如此反复，直到推出所有的$a_i$。考虑到$x_i = \\max(0,a_1,…,a_{i-1})$，我们可以令$ma = x_1$，这样每次迭代更新$ma = \\max(ma, a_i)$即可。 程序实现：1234567891011121314#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; long long n, ma = 0; cin &gt;&gt; n; for(int i = 1, x;i &lt;= n;i ++)&#123; cin &gt;&gt; x; cout &lt;&lt; x + ma &lt;&lt; \" \"; ma = max(x + ma, ma); &#125; return 0;&#125; C. Permutation Partitions描述：&emsp;&emsp;给你一个由$1到n$组成的序列，现给定$k(k\\leq n)$，要求将原序列分割成不重合的k段(这k段必须包含整个序列)。定义每段分区最大值的和为分区值，求： 最大分区值 使分区值取得最大的分区有多少种情况解题思路：&emsp;&emsp;对于第一个问题，显然的最大分区值就是从$n$向$n-k+1$求和的值。那么分区有多少种情况呢？我们考察$n$到$n-k+1$分割的$k+1$段序列长度。令$d_i = length\\ of\\ section\\ i$，那么显然答案应该为$\\prod_{i=1}^{k-1}{d_i+1}$。在实际处理种可以简单优化使得$d_i$的储存为$O(1)$的空间复杂度，整个算法只用遍里一次原数组。程序实现：12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;typedef long long ll;const ll MAXN = 200005;const ll MOD = 998244353;int main()&#123; ll n, k, ans1 = 0, ans2 = 1; ll dis = 0; cin &gt;&gt; n &gt;&gt; k; for(ll i = 0;i &lt; k;i++) ans1 += n - i; k = n - k + 1; for(ll i = 1, x;i &lt;= n;i++)&#123; cin &gt;&gt; x; if (x &gt;= k)&#123; if (dis != 0)&#123; ans2 *= (i - dis); ans2 %= MOD; &#125; dis = i; &#125; &#125; cout &lt;&lt; ans1 &lt;&lt; \" \" &lt;&lt; ans2; return 0;&#125; D. Prefix-Suffix Palindrome描述：给定字符串$s$，要求求它的一个最长字串$t$，满足： $t$是回文串 $t$由$s$的前缀和后缀拼接而成(前缀和后缀可为空串)解题思路：&emsp;&emsp;我们将$t$分成两部分，一个是前后缀中共同组成回文的部分，另一个是中间部分的回文串。对于前者我们直接逐个比较$s[i]==s[n-i-1]$即可。对于中间部分，我们将中间部分取出，设为$x$，现在的问题是求$x$的最大回文前缀或者最大回文后缀。 &emsp;&emsp;令我没有想到的是这个可以利用前缀数组求，即构造$x’=x+”*”+\\check{x}$，然后求一下前缀数组即可，最后一位前缀值就是最长的前缀回文长度。然后我们对$x$正序做一次，逆序做一次然后比较长度就可以了。 程序实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 2e6 + 5;int pi[MAXN], j;inline string solve_mid(const string s)&#123; string str = s; reverse(str.begin(), str.end()); str = s + \"#\" + str; int n = str.size(); pi[0] = 0, j = 0; for(int i = 1;i &lt; n;i++)&#123; while (j &gt; 0 &amp;&amp; str[j] != str[i]) j = pi[j - 1]; if(str[j] == str[i]) j++; pi[i] = j; &#125; return str.substr(0, j);&#125;inline void solve()&#123; string s; cin &gt;&gt; s; int n = s.size(); int i = 0; while (s[i] == s[n - i - 1] &amp;&amp; i &lt; n - i - 1) i++; if(i &gt; 0) cout &lt;&lt; s.substr(0, i); if(2 * i &lt; n)&#123; string sub = s.substr(i, n - 2 *i); string a = solve_mid(sub); reverse(sub.begin(), sub.end()); string b = solve_mid(sub); cout &lt;&lt; (a.size() &gt; b.size() ? a : b); &#125; if(i &gt; 0) cout &lt;&lt; s.substr(n - i, i); cout &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while (t--) solve(); return 0;&#125; 总结&emsp;&emsp;因为之前时间安排问题，这是我的第一篇题解(其实CF一直在打)。虽然自己很菜，也没想过能够在ACM上拿奖，但是总不能拉下太多吧。毕竟总不能刚开始来的时候大家一样菜，一年后人家摘金夺银你毫无进步吧。","categories":[{"name":"ACM Practice","slug":"ACM-Practice","permalink":"http://blog.raincur.com/categories/ACM-Practice/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.raincur.com/tags/Codeforces/"},{"name":"Solution","slug":"Solution","permalink":"http://blog.raincur.com/tags/Solution/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.raincur.com/tags/ACM/"},{"name":"learning","slug":"learning","permalink":"http://blog.raincur.com/tags/learning/"}]},{"title":"New life","slug":"New-life","date":"2020-03-16T16:02:54.000Z","updated":"2020-03-16T16:31:44.903Z","comments":true,"path":"2020/03/17/New-life/","link":"","permalink":"http://blog.raincur.com/2020/03/17/New-life/","excerpt":"&emsp;&emsp;自高考完以来，在挣扎中，在体悟中，我越来越领悟到友情、亲情等除了爱情之外的美好。","text":"&emsp;&emsp;自高考完以来，在挣扎中，在体悟中，我越来越领悟到友情、亲情等除了爱情之外的美好。 &emsp;&emsp;人是自以为是的，自以为正确的。我们总是在不自觉地为自己辩解。于是以往我一直觉得，“别人都不懂，没必要交流”，当然中二过后便是大错特错。我习惯于封锁内心，也习惯嘻嘻哈哈。我家人经常夸我，说我心理素质好，其实并不是，只是不知如何表达罢了。 &emsp;&emsp;我是幸运的，起码大学是幸运的。我很幸运拥有以为史杰佳一样的舍友。刚进大学，和我刚进入高中是一样的，因为一切都是新的。是时候重新定义自己。于是我对史敞开心扉，无话不谈。我的前女友，我又看上了谁，谁约我出去，我的过往。我知道他不会拿这些开玩笑，我也知道他愿意倾听。这改变了我很多。我开始慢慢变得真正的自信起来，慢慢地学会了如何与人交流。我开始慢慢注意别人是如何交流的，学习别人如何处理同性异性之间的关系，一点一点的。当出现矛盾时该退让还是坚守？面对对方或自己的问题应该如何解决？人与人交往的底线是什么？我是该生气还是应该谅解？ &emsp;&emsp;毫不避讳的说，我现在没有答案，我现在一无所知。我渴望我可以知道。我不想伤害别人，尤其是一个爱着你的你却不知甚至妄加猜测的人。 &emsp;&emsp;我之前写过，很多人改变了我。我也算是成年了，18载光阴不可白活。可是有时候细想过来，有几人可以真正地去谈一谈。这并不是说关系不好。我相信我有着一群朋友，可以接受我的逆境的朋友。只是我越发发现人和人的关系，并不是关系越好互相能做的事越多的。人和人是不同的，那么不同人之间的关系也不应该简单度量。这么显浅的道理，我曾为什么不懂呢？ &emsp;&emsp;秦旭曾经说，你和姬文萱是不一样的，你们在我生命中是不同的位置。我不明白，我说怎么会是不同的呢，我认为一个就够了。 &emsp;&emsp;现在发现确实很不同，有的人就是可以谈心，有的人就是会毫不犹豫帮你，有的人就是可以带来快乐，有的人就是给你心灵上的温暖。 &emsp;&emsp;我希望，或许在未来的某一天，秦旭，我们会再次相爱。我们会遇见很多矛盾，像之前一样。我们可以很轻松地互相开玩笑而不必当真。我们可以在朋友面前互损但是心里毫不介意。最终我们变得像家人一样，“学溶于水后看不见红色”。我们也许会犯错，但是是简单的，人都会犯错。 &emsp;&emsp;我希望可以像高考前那次那样，再来一次拥抱。除了你和家人，我只在初中毕业聚会上告别时礼节性的抱过一位异性。所以也许这么说有点讨巧，但是那真的是我目前为止最美妙的一个拥抱。起码在我的回忆中无比美好。 &emsp;&emsp;夕阳，高考，蛋糕，伊人，拥抱，暧昧。这些美好的元素汇集在一个下午。 &emsp;&emsp;又或许我早已没有权利去述说这一切。","categories":[{"name":"随笔杂谈","slug":"随笔杂谈","permalink":"http://blog.raincur.com/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.raincur.com/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"感悟","slug":"感悟","permalink":"http://blog.raincur.com/tags/%E6%84%9F%E6%82%9F/"}]},{"title":"谈幸福","slug":"谈幸福","date":"2020-03-11T15:19:26.000Z","updated":"2020-03-11T15:35:59.848Z","comments":true,"path":"2020/03/11/谈幸福/","link":"","permalink":"http://blog.raincur.com/2020/03/11/%E8%B0%88%E5%B9%B8%E7%A6%8F/","excerpt":"&emsp;&emsp;我曾一直在思考，什么是幸福？我们怎么幸福？","text":"&emsp;&emsp;我曾一直在思考，什么是幸福？我们怎么幸福？我做了一个大胆的假设，当我所有所期望的物质条件全部被满足之后（不再为钱而发愁，但也不至于“不爱钱，没碰过钱”），我就可以幸福了吗？ &emsp;&emsp;正如之前单身的时候（现在也是），总是期望能有一场甜掉牙的恋爱，也总是觉得有了女朋友，糖就来了。但是我发现事与愿违，总是有很多约束束缚着我们，老师家长同学等等。但其实最束缚的还是我们自己。我们无法做到开诚布公，也无法相信对方开诚布公，无法忍受对方的观念并为此大吵特吵。 &emsp;&emsp;爱情是需要酝酿的，不是想来的，是真的需要努力，努力地去挣脱自我的束缚的。爱情是一种能力。宽容、接受、交流、共情甚至你自身的一些特征，才能铸就爱情。谈恋爱时我常常痛恨自己不够幽默，不够大气，情商低，在面对困扰时束手无策。 &emsp;&emsp;幸福也如此。如果给了我足够的物质，不出意外我很可能会去放纵自己，虽然我知道沉浸在知识和探索中的快乐是长久而高尚的，但是远不及放纵来的轻易与猛烈。可是久而久之，原有的刺激就不再满足于我，而去追求更高的刺激，而每天醉生梦死之后只剩萧条。这样是真的快乐吗？是真的幸福吗？ &emsp;&emsp;有一天早上我打开联盟，打了一盘又一盘，没有人管我，打到最后只剩机械的点击鼠标，我的精神已经萎靡了，我需要休息，但是我不愿。因为这意味着放弃现有的刺激，虽然我知道休息后的快乐会多得多。 &emsp;&emsp;幸福不仅仅是一种状态，幸福更是一种能力。 &emsp;&emsp;幸福是需要自我约束的，“自律给我自由”这句话并不只是无用的鸡汤，更是有它其中的道理，真正自律了你才能摆脱刻在你基因中那些放纵的本性，修饰掉人固有的趋利避害性——只看眼前的趋利避害，从而让自己真正可以去做自己想做的事情，而不是做兽性的傀儡。 &emsp;&emsp;所以我们要在任何时候保持规律的作息和平静的心态。时时刻刻让自己的意志控制住自己，而不是让欲望绑架着自己。这是一种良好积极的生活态度，一把打开幸福之门的钥匙。真正的快乐，平淡而源远流长，蕴含在每天不经意的瞬间，绽放于心愿完成后的惊喜，而不是放纵后的枯燥无味。 &emsp;&emsp;很多时候，我们看似掌握全局，实则是在博弈。败者的下场只有一个，失去自我意志。","categories":[{"name":"随笔杂谈","slug":"随笔杂谈","permalink":"http://blog.raincur.com/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.raincur.com/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"看法","slug":"看法","permalink":"http://blog.raincur.com/tags/%E7%9C%8B%E6%B3%95/"}]},{"title":"Git&GitHub初体验","slug":"Github_first_try","date":"2020-02-28T07:18:31.000Z","updated":"2020-05-21T15:52:44.503Z","comments":true,"path":"2020/02/28/Github_first_try/","link":"","permalink":"http://blog.raincur.com/2020/02/28/Github_first_try/","excerpt":"&emsp;&emsp;在搭建博客的过程中开始真正接触到git这一强大的工具，也就很快对其产生了好奇心。于是写一篇博客来记录自己学习git和github的过程。","text":"&emsp;&emsp;在搭建博客的过程中开始真正接触到git这一强大的工具，也就很快对其产生了好奇心。于是写一篇博客来记录自己学习git和github的过程。 &emsp;&emsp;首先推一篇廖雪峰的博客，内容详实，语言幽默。我也是跟着这篇博客学习的。 git简介git是什么&emsp;&emsp;git是一个分布式的版本控制系统，可以帮助我们进行版本控制。而GitHub是一个远程的代码仓库，可以帮助我们进行代码托管。 安装git&emsp;&emsp;Windows下通过官网下载即可，安装提示安装后可以在cmd中通过git --version来查看自己是否配置成功。如图: 建立本地版本库版本库&emsp;&emsp;又名仓库，英文名为repository(就是github上的那个)，里面文件的操作可以被git记录，包括修改和删除，以便在需要的时候进行版本回退。在我看来，就好像在你的工作目录里面设置了一个机器人可以帮助你进行代码管理。当你完成工作后，就告诉它一声“我刚刚的工作完了，帮我作个记录吧！这次的工作是XXX”。然后某天你想回到之前的版本的时候，只需要给它说：“哦，上帝！我不小心搞砸了，请帮我回退到我做XXX工作的那次吧！”，然后就可以回退到之前的版本了。当然目前我的理解可能十分不到位……毕竟也是刚接触，对git的机理尚不熟悉。 使用git init初始化仓库&emsp;&emsp;我们在cmd中进入到自己的工程根目录所在的文件夹，然后使用git init命令就可以初始化一个仓库了。如图：然后在目录下我们可以看到多了一个名为.git的隐藏文件夹。里面是git的配置文件，我们无须关心，也不要去动。如图:这里为了演示我是新建了一个空文件夹，当让如果文件夹里面已经有了文件，也是被允许的。 修改仓库中的文件&emsp;&emsp;一般来说，每个仓库都会有一个README文件（起码我目前看到的是这样），用于告诉别人（因为git很常用于多人协作）这个项目是做什么的，里面的文件是什么等等，就起一个摘要的作用。所以我们给我们的仓库添加一个README文件，当然必须在仓库的根目录或者子目录里面创建，否则git是追踪不到的。根据廖雪峰老师的博客，git只能监视文本文件内容的具体改动，比如一个txt文件，你写了”Hello World”，这个是可以被git所具体知道的。但是如果一个二进制文件，比如一张图片，你把它裁剪了一部分，它只知道照片小了，但具体改动它是不明确的。(word也是二进制文件！震惊！) &emsp;&emsp;我们在仓库根目录下新建README.txt文件，更改里面的内容如下(不要使用记事本，这可能会带来意料之外的编码错误):12This is a README file.Glad to meet you.&emsp;&emsp;然后我们需要告知git我们对文件进行了修改，需要如下命令: &emsp;&emsp;第一步:使用git add [file name]告知git，我们将哪些文件添加到仓库1git add README.txt&emsp;&emsp;第二步:使用git commit告知git，将文件提交到仓库1git commit -m &quot;First commit&quot;&emsp;&emsp;其中,-m参数后面跟的是这次提交的描述。也就是我们改动了什么一类的内容。当然你可以随便写，但是最好是有实际意义，否则下一个接手的人可能想杀人。 &emsp;&emsp;当然这里有一个疑问，就是为什么将一个文件在版本库更新为什么要分两步呢？第一步add可以多次使用,选择不同的文件，然后使用commit一次提交。可以使用add .来选定所有文件。 &emsp;&emsp;至于具体的版本控制，emmmmmm这个我也不会，因为还没有用到过……所以还是先说一下github的使用。 远程仓库，GitHub创建远程仓库&emsp;&emsp;注册一个GitHub账号，在GitHub右上角可以创建一个新的远程仓库。如下图: &emsp;&emsp;点进去页面如下: &emsp;&emsp;用作演示，我们创建了一个名为GitHubTest的仓库，并且没有初始化README文件。如下图:(当然什么都没有) &emsp;&emsp;其中红框的部分是这个仓库的公钥，我们在本地根据这个公钥可以关联这个远程仓库。当然，别人的仓库你也是可以关联的，但是由于对方仓库的权限限制，你无法进行同步操作。 &emsp;&emsp;我们在cmd中进入到本地仓库的根目录，执行命令git remote add origin [仓库SSH],SSH即为前面图片框起来的部分。如图: &emsp;&emsp;似乎是什么都没发生，那就说明我们没做错。简洁的即是美的。 &emsp;&emsp;这个命令的作用是关联一个远程仓库，其中origin是这仓库的名字，当然你也可以用别的单词来代替。但origin是我们约定俗称的，用来表示远程仓库。 &emsp;&emsp;下面我们应用git push -u origin master将本地仓库推送到远程仓库上。 &emsp;&emsp;把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 &emsp;&emsp;由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。(这段是抄的) &emsp;&emsp;当我们查看我们的远程仓库时，你会惊奇地发现，我们的远程仓库已经有了和本地仓库一样的文件(第一次这么做的时候我惊喜了老半天，觉得好神奇)。如图: &emsp;&emsp;以后我们提交远程仓库，只需要使用git push origin master就可以了。","categories":[{"name":"github","slug":"github","permalink":"http://blog.raincur.com/categories/github/"}],"tags":[{"name":"learning","slug":"learning","permalink":"http://blog.raincur.com/tags/learning/"},{"name":"github","slug":"github","permalink":"http://blog.raincur.com/tags/github/"}]},{"title":"RainCurtain","slug":"RainCurtain","date":"2020-02-25T15:17:08.000Z","updated":"2020-03-11T15:50:28.116Z","comments":true,"path":"2020/02/25/RainCurtain/","link":"","permalink":"http://blog.raincur.com/2020/02/25/RainCurtain/","excerpt":"&emsp;&emsp;日子一天天地过，每天似乎毫无新意。","text":"&emsp;&emsp;日子一天天地过，每天似乎毫无新意。 &emsp;&emsp;今天19年10月14日，也不算是个什么特别的日子。不多能让我的这一天变得特殊的，或许就是在今天我开通了我的第一个博客吧。细想过来每一天都是那么的相似，不过是因为有了某些事情，才变得特殊起来，比如新生命的诞生，又比如挚爱的分别。 &emsp;&emsp;说起来写一个博客还是昨天ACM讲座听一位dalao演讲时建议的，说写一个博客，记录自己的学习历程，一方面可以记录自己生活中的点点滴滴，另一方面可以当作笔记来用，学完别人的再自己写一遍总会好很多，再一方面也算是互帮互助吧，在学习的过程中很多人给予了我们很多力量，我们也要给与更多人更多力量。 &emsp;&emsp;我给这篇文章取名为RainCurtain，这是恰好昨天许嵩发了一首新歌，名字就叫做雨幕，初听很平淡，旋律也是感觉很相似。细听好像有那么几分味道，曲子听起来也还不错。无所谓了，反正我无法做到客观中立，那我就自己开心好了。 &emsp;&emsp;雨幕，说起来我还真没想到西安也是一座“阴雨的小城”，来到西安，大半数时间都在阴雨天气吧，见到阳光是一件很奢侈的事情。我戏称这是西北的“梅雨季节”。 &emsp;&emsp;说实话西安给我的第一印象并不是很好，因为阴天。阴天，雨雾，给人以一种阴沉沉的感觉。虽然我喜欢阴雨。但是习惯了北湖的阳光与纯净的天空与新鲜的空气的我难免有些不适应。 &emsp;&emsp;不过想来喜欢阴雨，是因为它总能让我回忆起之前的一些事情，比如儿童时期雨天一起在村大队里的玩闹，比如初中那些在雨中在操场上在城市中的狂奔，又比如高中雨中的运动会，以及秦旭。不过来到西安后，这些都不见了，都离我远去了。想在雨天抽身找人一起闲逛聊聊之前，看看往后都找不到了。甚至想对望一眼恒大的那一件屋子也做不到了。见不到熟悉的人熟悉的景熟悉的事。“叹一句当时只道是寻常” &emsp;&emsp;不过现在也会变成寻常吧，我猜。 &emsp;&emsp;其实很多事情就是这样吧，当你觉得以后总会有很多的时候，最后你才会发现原来“盛庭难在”。就像之前那一段时间秦旭几乎每个星期都陪我出去玩，我就以为以后我们出来玩的时间多着呢，然后就再没出来过。就像暑假秦旭说：这是我最后一次和你出来了；然后那以后我到现在还没再见到她，除了在梦里和在网上。 &emsp;&emsp;挺好的，现在就挺好的我觉得。真的挺好的。我不想再有什么改变，但我知道这种状态是一种伪装的平衡，指不定哪天就突然消失不见，只剩下怀念。 &emsp;&emsp;那我不如好好珍惜这最近慵懒平静开心自由的快乐生活，在它远离之前好好的享受它。毕竟谁也不知道明天会不会突然世界毁灭或者猝死。 &emsp;&emsp;也许人世间一切的美好都是短暂的，短暂所以美丽。终会消逝。与其祈求长久，不如把握当下，珍惜时光。 &emsp;&emsp;或许这样便可留住快乐，或者说，坦坦荡荡好过忧情伤神。 &emsp;&emsp;说了这么多，似乎是和“雨幕”没有什么关系。也没必要有什么关系，只不过是从下雨让我联想到了很多事情罢了。 The world is a dream in rain The splashes of water shines don’t you see Watch out Don’t step on the fish in the pool I’m a little soaking mouse I’m wet with a blanket of rain And I dream of you","categories":[{"name":"随笔杂谈","slug":"随笔杂谈","permalink":"http://blog.raincur.com/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.raincur.com/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"情绪","slug":"情绪","permalink":"http://blog.raincur.com/tags/%E6%83%85%E7%BB%AA/"}]}],"categories":[{"name":"随笔杂谈","slug":"随笔杂谈","permalink":"http://blog.raincur.com/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"},{"name":"ACM-Math","slug":"ACM-Math","permalink":"http://blog.raincur.com/categories/ACM-Math/"},{"name":"ACM Practice","slug":"ACM-Practice","permalink":"http://blog.raincur.com/categories/ACM-Practice/"},{"name":"github","slug":"github","permalink":"http://blog.raincur.com/categories/github/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.raincur.com/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"Reflection","slug":"Reflection","permalink":"http://blog.raincur.com/tags/Reflection/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.raincur.com/tags/ACM/"},{"name":"learning","slug":"learning","permalink":"http://blog.raincur.com/tags/learning/"},{"name":"Math","slug":"Math","permalink":"http://blog.raincur.com/tags/Math/"},{"name":"看法","slug":"看法","permalink":"http://blog.raincur.com/tags/%E7%9C%8B%E6%B3%95/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.raincur.com/tags/Codeforces/"},{"name":"Solution","slug":"Solution","permalink":"http://blog.raincur.com/tags/Solution/"},{"name":"感悟","slug":"感悟","permalink":"http://blog.raincur.com/tags/%E6%84%9F%E6%82%9F/"},{"name":"github","slug":"github","permalink":"http://blog.raincur.com/tags/github/"},{"name":"情绪","slug":"情绪","permalink":"http://blog.raincur.com/tags/%E6%83%85%E7%BB%AA/"}]}